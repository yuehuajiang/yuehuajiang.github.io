<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://yuehuajiang.github.io</id>
    <title>抗马拉硫磷的小菜蛾</title>
    <updated>2020-03-01T03:50:22.468Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://yuehuajiang.github.io"/>
    <link rel="self" href="https://yuehuajiang.github.io/atom.xml"/>
    <subtitle>自是人生长恨水长东</subtitle>
    <logo>https://yuehuajiang.github.io/images/avatar.png</logo>
    <icon>https://yuehuajiang.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 抗马拉硫磷的小菜蛾</rights>
    <entry>
        <title type="html"><![CDATA[线性表的顺序储存结构和实现]]></title>
        <id>https://yuehuajiang.github.io/post/xian-xing-biao-de-shun-xu-chu-cun-jie-gou-he-shi-xian/</id>
        <link href="https://yuehuajiang.github.io/post/xian-xing-biao-de-shun-xu-chu-cun-jie-gou-he-shi-xian/">
        </link>
        <updated>2020-03-01T03:31:42.000Z</updated>
        <content type="html"><![CDATA[<h2 id="完整程序如果你比较懒就不用往下看了">完整程序(如果你比较懒就不用往下看了)</h2>
<p>DEV C++编译环境</p>
<pre><code class="language-c"> #include&lt;stdlib.h&gt;
 #include&lt;stdio.h&gt;
 typedef int ElemType;


//线性表的顺序定义
typedef struct seqList
{
	int n;
	int maxLength;
	ElemType *element;
 } SeqList;


//顺序表的初始化 
#define ERROR 0
#define OK 1
#define OverFlow 2//上溢 
#define UnderFlow 3//下溢 
#define NotPresent 4//元素不存在 
#define Duplicate 5//有重复元素 
typedef int Status;
Status Init (SeqList *L,int mSize)
{
	L-&gt;maxLength=mSize;
	L-&gt;n=0;
	L-&gt;element=(ElemType*)malloc(sizeof(ElemType)*mSize);//动态生成一维数组空间 
	if(!L-&gt;element)
		return ERROR;
	return OK; 
 } 
 
 
 //顺序表的查找
 Status Find(SeqList L,int i,ElemType *x)
 {
 	if(i&lt;0||i&gt;L.n-1)//判断元素下标i是否越界 
		return ERROR; 
	*x=L.element[i];//取出element[i]值通过参数x返回 
	return OK;
  } 
  
//顺序表的元素插入
Status Insert(SeqList*L,int i,ElemType x)
{
	int j;
	if(i&lt;-1||i&gt;L-&gt;n-1)//判断下标是否越界 
		return ERROR;
	if(L-&gt;n==L-&gt;maxLength)//判断顺序表存储空间是否已满 
		return ERROR;
	for(j=L-&gt;n-1;j&gt;i;j--)
		L-&gt;element[j+1]=L-&gt;element[j];//从前往后逐个后移元素
	L-&gt;element[j+1]=L-&gt;element[j];
	L-&gt;element[i+1]=x;
	L-&gt;n=L-&gt;n+1;
	return OK;
	 
 } 
Status Delete(SeqList *L,int i)
{
	int j;
	if(i&lt;0||i&gt;L-&gt;n-1)//下标i是否越界 
		return ERROR;
	if(!L-&gt;n)		//顺序表是否为空 
		return ERROR; 
	for(j=i+1;j&lt;L-&gt;n;j++)
		L-&gt;element[j-1]=L-&gt;element[j];//从前往后逐个前移元素 
	L-&gt;n--;			//表长减一 
	return OK;
}
 
 
 //顺序表的输出
 Status Output(SeqList *L)
 {
 	int i;
 	if(L-&gt;n==0)//判断顺序表是否为空 
 		return ERROR;
	for(i=0;i&lt;=L-&gt;n-1;i++)
		printf(&quot;%d&quot;,L-&gt;element [i]);
	printf(&quot;\n&quot;);
	return OK; 
  } 
 //顺序表的撤销
 void Destroy(SeqList *L)
 {
 	L-&gt;n=0;
 	L-&gt;maxLength=0;
 	free(L-&gt;element);
  } 
 //主函数
main()
{
	int i;
	SeqList list;
	
	Init(&amp;list,10);//初始化线性表 
	
	for(i=0;i&lt;10;i++)
		Insert(&amp;list,i-1,i);//线性表中插入新元素
	Output(&amp;list);
	
	Delete(&amp;list,0);
	Output(&amp;list); 
	Destroy(&amp;list);	
}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://yuehuajiang.github.io/post-images/1583033551748.png" alt="" loading="lazy"></figure>
<p>正文开始</p>
<h2 id="线性表的顺序储存结构">线性表的顺序储存结构</h2>
<h4 id="线性表的顺序定义">线性表的顺序定义</h4>
<pre><code class="language-c">typedef struct seqList
{
	int n;//顺序表的长度
	int maxLength;//顺序表的最大允许长度
	ElemType *element;//顺序表的储存空间的首地址
 } SeqList;
</code></pre>
<p>ElemType是自定义类型，你可以通过 typedef int ElemType将其转化为int型或者转化为你需要的任意数据类型。</p>
<h2 id="顺序表基本运算的实现">顺序表基本运算的实现</h2>
<h4 id="顺序表的初始化">顺序表的初始化</h4>
<pre><code class="language-c">#define ERROR 0
#define OK 1
#define OverFlow 2//上溢 
#define UnderFlow 3//下溢 
#define NotPresent 4//元素不存在 
#define Duplicate 5//有重复元素 
typedef int Status;
Status Init (SeqList *L,int mSize)
{
	L-&gt;maxLength=mSize;
	L-&gt;n=0;
	L-&gt;element=(ElemType*)malloc(sizeof(ElemType)*mSize);//动态生成一维数组空间 
	if(!L-&gt;element)
		return ERROR;
	return OK; 
 } 
</code></pre>
<h4 id="顺序表的查找">顺序表的查找</h4>
<pre><code class="language-c"> Status Find(SeqList L,int i,ElemType *x)
 {
 	if(i&lt;0||i&gt;L.n-1)//判断元素下标i是否越界 
		return ERROR; 
	*x=L.element[i];//取出element[i]值通过参数x返回 
	return OK;
  }
</code></pre>
<h4 id="顺序表的元素插入">顺序表的元素插入</h4>
<pre><code class="language-c">Status Insert(SeqList*L,int i,ElemType x)
{
	int j;
	if(i&lt;-1||i&gt;L-&gt;n-1)//判断下标是否越界 
		return ERROR;
	if(L-&gt;n==L-&gt;maxLength)//判断顺序表存储空间是否已满 
		return ERROR;
	for(j=L-&gt;n-1;j&gt;i;j--)
		L-&gt;element[j+1]=L-&gt;element[j];//从前往后逐个后移元素
	L-&gt;element[j+1]=L-&gt;element[j];
	L-&gt;element[i+1]=x;
	L-&gt;n=L-&gt;n+1;
	return OK;
	 
 } 
</code></pre>
<h4 id="顺序表的元素删除">顺序表的元素删除</h4>
<pre><code class="language-c">Status Delete(SeqList *L,int i)
{
	int j;
	if(i&lt;0||i&gt;L-&gt;n-1)//下标i是否越界 
		return ERROR;
	if(!L-&gt;n)		//顺序表是否为空 
		return ERROR; 
	for(j=i+1;j&lt;L-&gt;n;j++)
		L-&gt;element[j-1]=L-&gt;element[j];//从前往后逐个前移元素 
	L-&gt;n--;			//表长减一 
	return OK;
}
</code></pre>
<h4 id="顺序表的输出">顺序表的输出</h4>
<pre><code class="language-c"> Status Output(SeqList *L)
 {
 	int i;
 	if(L-&gt;n==0)//判断顺序表是否为空 
 		return ERROR;
	for(i=0;i&lt;=L-&gt;n-1;i++)
		printf(&quot;%d&quot;,L-&gt;element [i]);
	printf(&quot;\n&quot;);
	return OK; 
  } 
</code></pre>
<h4 id="顺序表的撤销">顺序表的撤销</h4>
<pre><code class="language-c"> void Destroy(SeqList *L)
 {
 	L-&gt;n=0;
 	L-&gt;maxLength=0;
 	free(L-&gt;element);
  } 
</code></pre>
<h4 id=""></h4>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[顺序表课后习题]]></title>
        <id>https://yuehuajiang.github.io/post/shun-xu-biao-ke-hou-xi-ti/</id>
        <link href="https://yuehuajiang.github.io/post/shun-xu-biao-ke-hou-xi-ti/">
        </link>
        <updated>2020-02-29T08:46:07.000Z</updated>
        <content type="html"><![CDATA[<p>醉了，原本想着自己弄明白的，结果还是抄了别人的作业</p>
<p>算了，弄明白最重要</p>
<h3 id="一-请完成下列算法填空实现对顺序表逆置存储逆置存储是指将元素线性关系逆置后的顺序存储例如a0a1a2关系逆置后a2a1a0">一、请完成下列算法填空实现对顺序表逆置存储，逆置存储是指将元素线性关系逆置后的顺序存储，例如（a0,a1,a2），关系逆置后（a2,a1,a0).</h3>
<p>SeqList的结构体定义如下：</p>
<pre><code class="language-c">typedef struct seqList
{
    int n;
    int maxLength;
    ElemType *element;
}SeqList;
</code></pre>
<h3 id="题目">题目</h3>
<pre><code class="language-c">void Invert(SeqList *L) {
ElemType temp; int i; 
for ( i=0; i&lt;________; i++) { 
    temp =____________; 
    L-&gt;element[i] = L-&gt;element[___________]; 
    L-&gt;element[________] = ___________; }
}
</code></pre>
<h3 id="答案这个是我自己写的">答案(这个是我自己写的)</h3>
<p>题目给了中间变量，很可能是用到交换的法</p>
<pre><code class="language-c">void Invert(SeqList *L) {
ElemType temp; int i; 
for ( i=0; i&lt;n; i++)//从首尾向中间靠拢 
{ 
    temp =L-&gt;element[i]; 
    L-&gt;element[i] = L-&gt;element[n-i];//将首端和尾端的元素互换
    L-&gt;element[n-i] = temp; 
}

</code></pre>
<h3 id="二-请完成下列算法填空现对单链表的逆置存储逆置存储是指将元素线性关系逆置后的链表存储例如a0a1a2关系逆置后为a2a1a0">二、请完成下列算法填空现对单链表的逆置存储，逆置存储是指将元素线性关系逆置后的链表存储，例如（a0,a1,a2），关系逆置后为（a2,a1,a0).</h3>
<p>单链表结点Node和单链表SingleList结构体定义如下：</p>
<pre><code class="language-c">typedef struct node
{
     ElemType element;
     struct node *link;
}Node;

typedef struct singlelist
{
    Node *first;
    int n;
}SingleList;
</code></pre>
<h3 id="题目-2">题目</h3>
<pre><code class="language-c">void invert(SingleList *L) 
{ 
	Node *p=__________,*q; 
	L-&gt;first=NULL; 
	while (_____)
    { 
    	q=p-&gt;link; 
    	p-&gt;link=_______; 
    	L-&gt;first=_______; 
   		p=_______; 
    } 
}
</code></pre>
<h3 id="答案">答案</h3>
<pre><code class="language-c">void invert(SingleList *L) 
{ 
	Node *p=L-&gt;first,*q; 
	L-&gt;first=NULL; 
	while (p!=NULL)
    { 
    	q=p-&gt;link; 
    	p-&gt;link=L-&gt;first; 
    	L-&gt;first=p; 
   		p=q; 
    } 
}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://yuehuajiang.github.io/post-images/1582967257324.jpg" alt="" loading="lazy"></figure>
<h3 id="三-完成下列算法填空将两个有序递增的带表头结点的单链表合并为一个有序递增的单链表">三、完成下列算法填空，将两个有序递增的带表头结点的单链表合并为一个有序递增的单链表。</h3>
<p>链表结点Node和链表SingleList结构体定义如下：</p>
<pre><code class="language-c">typedef struct node
{
     ElemType element;
     struct node *link;
}Node;

typedef struct headerlist
{
    Node *head;
    int n;
}HeaderList;
</code></pre>
<h3 id="题目-3">题目</h3>
<pre><code class="language-c">void MergeList1(HeaderList *La,HeaderList *Lb,HeaderList *Lc) { 
//合并链表La和Lb，合并后的新表使用头指针Lc指向 
Node *pa,*pb,*pc,*q;
pa=La-&gt;head-&gt;link; 
pb=Lb-&gt;head-&gt;link; 
pc=Lc-&gt;head; 
while(pa &amp;&amp; pb) {
     if(____________________) { 
           pc-&gt;link=pa; 
           pc=pa; 
           pa=pa-&gt;link; 
           La-&gt;n--; }
     else if(pa-&gt;element&gt;pb-&gt;element) { 
           pc-&gt;link=___________; 
           pc=________; 
           pb=_________;
           Lb-&gt;n--; } 
      else { 
           pc-&gt;link=pa; 
           pc=pa; 
           pa=_________; 
           q=_________; 
           free(pb); 
           pb =q; } 
Lc-&gt;n++; } 
pc-&gt;link=pa?pa:pb; //插入剩余段 Lc-&gt;n+=pa?La-&gt;n:Lb-&gt;n; 
}
</code></pre>
<h3 id="答案-2">答案</h3>
<pre><code class="language-c">void MergeList1(HeaderList *La,HeaderList *Lb,HeaderList *Lc) { 
//合并链表La和Lb，合并后的新表使用头指针Lc指向 
Node *pa,*pb,*pc,*q;
pa=La-&gt;head-&gt;link; 
pb=Lb-&gt;head-&gt;link; 
pc=Lc-&gt;head; 
while(pa &amp;&amp; pb) {
     if(pa-&gt;element&lt;pb-&gt;element) { 
           pc-&gt;link=pa;//把pa挂在pc上 
           pc=pa; 
           pa=pa-&gt;link;//往后 
           La-&gt;n--; }
     else if(pa-&gt;element&gt;pb-&gt;element) { 
           pc-&gt;link=pb; 
           pc=pb; 
           pb=pb-&gt;link;
           Lb-&gt;n--; } 
      else { 
           pc-&gt;link=pa; 
           pc=pa; 
           pa=pa-&gt;link; 
           q=pb-&gt;link; 
           free(pb); 
           pb =q; } 
Lc-&gt;n++; } 
pc-&gt;link=pa?pa:pb; //插入剩余段 Lc-&gt;n+=pa?La-&gt;n:Lb-&gt;n; 
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://yuehuajiang.github.io/post/hello-gridea/</id>
        <link href="https://yuehuajiang.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>